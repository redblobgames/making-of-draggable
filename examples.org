#+title: Draggable objects: examples
#+date: <2023-12-01 Fri>
#+property: header-args:dot    :cache yes
#+draft: t

On the [[href:./][main page]] I show the /event handler recipe/ I use for dragging objects around in my interactive diagrams. That's only handles the /input/. It doesn't draw or move anything. The
@@html:<em style="background:#e6d4c3"> event handler </em>@@
needs to be connected to a
@@html:<em style="background:#cfd6e6"> state handler </em>@@.  The state handler handles the /output/.

#+begin_src dot :file build/diagram-state-and-event-handlers.svg
digraph Handlers {
  node [
    style="filled"
    color="white"
    fillcolor="0.15 0.02 0.90"
    fontname="monospace"
    fontsize=16
  ]
  edge [color="0.15 0.05 0.75"]
  rankdir = "LR"

  subgraph cluster_0 {
    style="filled"
    color="#f8f4f0"
    event [
      shape = record
      fillcolor="#e6d4c3"
      label = "<down> pointerdown | <up> pointerup | <move> pointermove";
    ];
    event;
    browser -> event;
    label="main page";
  }

  subgraph cluster_1 {
    style="filled"
    color="#f0f4f8"
    state [
      shape = record
      fillcolor="#cfd6e6"
      label = "event to coords | <dragging> dragging | <pos> pos";
    ];
    state -> "application state";
    state -> dom;
    label="examples page";
  }

  event:down -> state:dragging;
  event:up -> state:dragging;
  event:move -> state:pos;
}
#+end_src

#+results[1448242050c1bc0770103c323e50452fdc75dbc4]:
[[file:build/diagram-state-and-event-handlers.svg]]

This structure gives me the flexibility I want for my projects. The state handler isn't limited to /dragging/, or a fixed set of behaviors. This is /unlike/ the design of libraries like jquery-ui-draggable or react-draggable. Those libraries give me a list of predefined behaviors like snapping to a grid or constrained movement or using a handle, but the behavior I want isn't always in that list. In my projects I decouple the drag event handler from the state handler, so I can implement any of those, and more, such as scrubble numbers or a painting program. On this page I'll give examples with code you can use. Although I treat the state handlers and event handlers as separate concepts, in practice I will sometimes combine the two.

* Vanilla JS examples
:PROPERTIES:
:CUSTOM_ID: vanilla-js-examples
:END:

*These examples are starting points* using global variables. You'll have to adapt the recipe to fit into your own project.

#+begin_export html
<show-example name="svg-circle">
  Here's a basic state handler that works with the event handler. The position
  <code>pos</code> has a <em>setter</em> on it that also updates the circle's
  position whenever the position variable is changed. The event handler sets
  the <code>dragging</code> CSS class, which changes the color of the circle
  while it's being dragged.
</show-example>

<show-example name="svg-constrained">
  In this state handler the setter for <code>pos</code> clamps the x and y positions to
  stay within a rectangular area.
</show-example>

<show-example name="svg-snapping">
  In this state handler the setter for <code>pos</code> snaps the x,y position to
  the nearest gray dot. On the left is snap-to-grid as seen in other libraries
  but the right side shows the flexibility of being able to write my own state handler. This example
  also shows how the internal representation <code>[x,y]</code> can be different from the
  external type <code>{x,y}</code>.
</show-example>

<show-example name="div">
  Here's the classic dragging of a <code>&lt;div&gt;</code> by setting its
  <code>transform</code> CSS property. In this example <code>eventToCoordinates</code>
  doesn't need to transform the coordinate system. The position is constrained
  to the container <code>&lt;div&gt;</code>. To switch to absolute
  positioning, the <code>set pos()</code> function would change, but
  the event handler code would not.
</show-example>

<show-example name="div-handle">
  There's a lot of flexibility in changing what's draggable separately from how the position is updated.
  Here's a recreation of one example from <a href="https://react-grid-layout.github.io/react-draggable/example/">React-Draggable</a>. The event handlers connect to the <em>red</em>
  handle, but the state handler updates the position of the <em>white</em> containing box.
</show-example>

<show-example name="number-scrubbing">
  The drag events don't have to involve moving anything.
  This example shows how they can be used for changing the
  number stored in an <code>&lt;input&gt;</code> element.
  I use this type of interaction on my <a href="/articles/probability/damage-rolls.html">Damage Rolls page</a>.
  Since it's a standard element I can change it with
  keyboard/mouse in addition to dragging. However, the standard
  input event has styling and text selection that may interfere
  with dragging, so some people use a <code>&lt;span&gt;</code>
  instead.
</show-example>

<show-example name="canvas-drawing">
  Here's another example of how the drag events don't have
  to move anything. Here we <em>don't</em> want to keep track
  of the initial offset in the pointerdown event. Draw on the canvas:
</show-example>

<show-example name="canvas-drag-circle">
  Here we're not dragging any DOM element. The canvas
  stays in place. But I'm moving a marker that's drawn
  on the canvas. I had to modify the event handler recipe
  to update the cursor whenever anything happened.
</show-example>

<show-example name="svg-painting">
  This example shows multi-state painting. It remembers the color
  you are painting with, and keeps using it until the pointer up event.
  The event handling in this example differs from the
  standard recipe enough that I don't know if it's really worth
  keeping the state separate from the events. Each square has
  an event handler, and we <em>release</em> the pointer capture
  so that the pointer move goes to other squares while painting.
  But that also means this doesn't behave properly when moving
  the mouse outside the painting area and then back in.
</show-example>

<show-example name="linked-circles">
  State can be shared between draggables. Here, the x position
  is separate and the y position is shared.
</show-example>

<show-example name="nested-element">
  When nesting draggable elements, use <kbd>stopPropagation()</kbd>
  to prevent the inner draggable from sending events to the outer
  draggable handler.
  <!--  Original demo
   https://sfc.vuejs.org/#eNq1VU1zmzAQ/StbJjPYUxs7V+p02mkvveXQQzLDIdisQSlIGknYUMp/7wpBCo4b99M+oH37Vuy+XaTGey9lcCjRC72N3ikmDWg0pXwbcVZIoQw0oHAPLeyVKMAnqh/xiO8E1wYquLHe2Xo+IPUz5MgSk/Xo9foHniFLMzNxDK5ExSk5mohDt04ZT0PYx7nGhcWkYNygSsSRz/CA3MwdF8BkTAdDiN0iqUKogkOclwhL6MjBLmf0uFtAUodQn3Xet2/chj1YKkXPz7FK0QQk0K3L4EMsTanQJRH0aX1K5l1wO861lBcy7ap7HleIQ7/9UyTbw+zVJHxOGlIevM95qPdmWi+8nr40SKo+YNBgGnD/PKB+SrAdeqVQs6829J906xi6eflpx7KwH5z/1rYhWBshb5WQcRobJvjs75r6G7v+Sctf2hwmkl4cimMfNJH54mRk48nYrNxRQocIGQYLmccGyQLYJOwAoTZ1jjeR1xgVc70XqgjhoVtb4uyqqVpZLa6amh7zh4UrgChXTbcilECXYIe6pYO38e5LqkTJkxD8GvNcHP0F+KVGtdSY48745OCCI8FSaGalIkQhvZsdLEpzo4UizLbCbyPPKUK/d6NhDnLcGyrCijAMkcXP0Et5wivlGZZ92wnPQiNmJyHAR3s+FgiNk+Pbum3vml4EazjWidSjUuOtFnlpbKnKaeivab0VxgjqRGf0kvvXa1mROYg92BOVFSZj1fhR49KdCxfFc7RfkW/KfEnAKfNEwicRNyvSx81kv9qsRqPq/t7Cc9fgsohl8KgFp4uy+yij3qEjLxw+08ij69HakZcZI3W4Wun9zl6vjzoQKl3RKlAlN6zAAHWx3CpBWina2GVInWu99ju1AZkh
  -->
</show-example>
#+end_export

* Vue component
:PROPERTIES:
:CUSTOM_ID: vue-examples
:END:

I use Vue in many of my projects. The event handlers can be put into a Vue  component that wraps a draggable element. This example is an SVG ~<g>~ wrapper, but the code would be similar for a ~<div>~ wrapper.

To use this component, create position variables (=data= in Options API or =ref= in Composition API) of type ={x, y}=, and then draw the desired shape as the child slot of the draggable component. In this example, I have =redCircle= and =blueSquare= positions:

#+begin_src vue
<svg viewBox="-100 -100 200 200" style="background: gray">
  <Draggable v-model="redCircle">
    <circle r="10" fill="red" />
  </Draggable>
  <Draggable v-model="blueSquare">
    <rect x="-10" y="-10" width="20" height="20" fill="blue" />
  </Draggable>
</svg>
#+end_src

*[[https://play.vuejs.org/#eNrtV2tv2zYU/SsXXofImS2lAfbFSfbyimEYhgZIUGyYh1WWrmQ2kqiRlB8z/N93SD0sO26WtRj2pQZsi+S5l/d5RG4H35alv6x4MBkE58TrMC8zJplQrMKUwiLGgywpkYr0MiXOOOfC6KtZQURRWNCcKZexSATHZCStpHqglTALWpg86/BYkrWMZsaSKfUkCFarla84nmdynoY5az+SeZCHD6JIxzIJrAlpOM84oPNgVsyKax0pURroMFX5lVUn8lIqQ1vFyY4SJXM6gzNnbqsgaJe/bxU1ED/oZl6XRshC2xDUUv8sMpWAaGHl9mL2G0GRITg0FSqC5A2eE2+7ntCXFyPaTGh8ebEbOngNnWcV3/1ZhaqPHTfgBnsd1E7DXQwMIz+hYef8tc3IUvDqO7m+mQ3GLy8urDQkLwjPswFps8kYS/MwekiVrIp4Qp8x82zgFEDF3s/lGHnkDOjOgw4GYFT7pLD+0qpORGaxC515F/Dvc/sdYj5oNe8D9tRe+xD0N1McGWp8gs5N97QSsVlgdGkHCxbpwrSjnkGXl88yCaFdpni6DnphHYwG78s0euQoAWmteGJUWGj0SA4D3rqBxXgvts7NNyGc9Ne70cF4sxu+nQ1qBd+UUhSGVSxXhZ9xYp3SJlTmGFCVWOEihlftFJowcqF004fwXC5t+l0joanoa/TqEnbxEk05pAkVVZZ1QkZW0cJt65fKQSBrd7Lyj+cb36Ms1BoT23aX3b66dCZNE/7r4FGojxu67qKnWrpdQ/ssWZlbsebsXt4t06mUKm7hvs1rZGe0/04f92cJPtPot5gTUfCtHXnb2t59dib0ev7OFiFIRC9klcWW6LZrdObOYps23mvlXJhO6SsMtPfbWVXG8HSyV3v2+9C63Qp1eam7PwkzzVaxRSRVEdnCQw8j8F6TscZQkVA940dGZT/xZggFplJFzbGUMYLkjIXq08FqNDYCrSX+0poJoW0MKnKh8vs1TGOC2hj09Ghtg7XNrtHXGFcphf/7UKVsfCT5ti7LaVjCWG5caGr1x7g2BvE98B9lfeT9I2NtFZ+UddV+KPyvQ2Mz651I5ajVSIRQremLI7v8eD1qAYjX5gRg0wCaaoL1h2zv6Jt0JEuOXROltCUEVUs1oVSF8ysrg2m/q6QtVZrVWOPFGxn0tyz46kBkDpQTw1ZW/RHl9d6Hn+juP6K7g5PLh1EZr5006CasMmhx88b15IR6YW95bDd6H5OhnUITeuiPhkLw0Lo2IUdJtEPBoFRnBhTJZiFju0lb26f46Tkc9UHNaD9mIfS+4BuqcpOnmep46YCoPpKsXPd2bW6p6o/HkTg2uKOrQ+kTZPVxMXrxDOrq0deBmX326jHYEaYlsB6J9X3a2Z//mdn6/eMuOec0rYNYt5gLHeIKiCgQJ9JlGDF5eHuYBVMZpjy0F5u7Nz/0ULDtvEXa246o0dhsRAtZSGUtVqxLcKlY4tjMWvyFuVF9gg3qo6sN07m7ZDWn+KG76DTN3b3Fnkr6CFesmxMF3JVQfdKwN4UbQH0wLiv48qq+mPXOCyUAgPmRYjgIiKt/r81qiZaChnqnTODvl25lc7Tya7uC+dLPQ6PE+r59Z3h2E1h4h424mN7/7A19YR3U7A3b3RoqKjFEQge7vwFtIua8][Run it on the Vue Playground]],* with either the Options API or Composition API components. Or browse the component source code here:

#+begin_export html
<details>
<summary><b>&lt;Draggable&gt; component</b>, Options API:</summary>
#+end_export

#+begin_src vue
<template>
  <g
    :transform="`translate(${modelValue.x},${modelValue.y})`"
    :class="{dragging}"
    @pointerdown.left="start"
    @pointerup="end" @pointercancel="end"
    @pointermove="dragging ? move($event) : null"
    @touchstart.prevent="" @dragstart.prevent="">
    <slot />
  </g>
</template>

<script>
  import {eventToSvgCoordinates} from './svgcoords.js';

  export default {
    props: {modelValue: Object}, // should be {x, y}
    data() { return { dragging: false }; },
    methods: {
      start(event) {
        if (event.ctrlKey) return;
        let {x, y} = eventToSvgCoordinates(event);
        this.dragging = {dx: this.modelValue.x - x, dy: this.modelValue.y - y};
        event.currentTarget.setPointerCapture(event.pointerId);
      },
      end(_event) {
        this.dragging = null;
      },
      move(event) {
        let {x, y} = eventToSvgCoordinates(event);
        this.$emit('update:modelValue', {
          x: x + this.dragging.dx,
          y: y + this.dragging.dy,
        });
      },
    }
  }
</script>

<style scoped>
  g { cursor: grab; }
  g.dragging { user-select: none; cursor: grabbing; }
</style>
#+end_src

#+begin_export html
</details>

<details>
<summary><b>&lt;Draggable&gt; component</b>, Composition API:</summary>
#+end_export


#+begin_src vue
<template>
  <g
    :transform="`translate(${modelValue.x},${modelValue.y})`"
    :class="{dragging}"
    @pointerdown.left="start"
    @pointerup="end" @pointercancel="end"
    @pointermove="dragging ? move($event) : null"
    @touchstart.prevent="" @dragstart.prevent="">
    <slot />
  </g>
</template>

<script setup>
  import {ref} from 'vue';
  import {eventToSvgCoordinates} from './svgcoords.js';

  const props = defineProps({
    modelValue: Object // should be {x, y}
  });

  const emit = defineEmits(['update:modelValue'])

  const dragging = ref(false);

  function start(event) {
    if (event.ctrlKey) return;
    let {x, y} = eventToSvgCoordinates(event);
    dragging.value = {dx: props.modelValue.x - x, dy: props.modelValue.y - y};
    event.currentTarget.setPointerCapture(event.pointerId);
  }

  function end(event) {
    dragging.value = null;
  }

  function move(event) {
    let {x, y} = eventToSvgCoordinates(event);
    emit('update:modelValue', {
      x: x + dragging.value.dx,
      y: y + dragging.value.dy,
    });
  }
</script>

<style scoped>
  g { cursor: grab; }
  g.dragging { user-select: none; cursor: grabbing; }
</style>
#+end_src

#+begin_export html
</details>
#+end_export

If you're using Vue v2 (whether Options API or Composition API), you'll need to change the v-model prop from =modelValue= to =value= and the event from =update:modelValue= to =input=.

Add /computed setters/ on the model value to apply constraints like bounds checking or grid snapping. 

* More examples
:PROPERTIES:
:CUSTOM_ID: more
:END:

TODO: more examples I'm considering:

2. invisible larger drag area for mobile (from my little-details page)
4. constrain position to a non-rectangular area, like my [[href:/articles/curved-paths/making-of.html][making-of curved-paths page]]
5. accessibility - make the numbers also show up in an =<input>= box, or make things draggable by keyboard? - something for the vue playground
6. =.dragging= class options (from little-details page)
7. maybe a React or Svelte example

Although I think of the state handling and the event handling as separate concepts, I will sometimes "inline" the state handling into the event handling code.

#+begin_export html
<style>
  show-example {
    display: block;
  }
  iframe {
    display: block;
    width: 100%;
    border: 0;
    box-shadow: 0 1px 2px rgba(0 0 0 / 0.5);
  }

  show-example {
    display: grid;
    width: unset;
    margin-inline: 0.5em;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto auto min-content;
    grid-template-areas:
        'title editors'
        'explanation explanation'
        'demo demo'
        'code code';
    border-top: 1em solid hsl(var(--hue), 50%, 45%);
  }
  show-example > .code {
    grid-area: code;
  }
  show-example > .code summary {
    max-width: var(--body-width);
    margin: auto;
  }
  show-example > .code > div {
    display: grid;
    margin-inline: 0.5em;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 7em 7em 9em;
    grid-template-areas:
        'state body'
        'state style'
        'state event';
  }

  show-example > h3 { grid-area: title; margin: 1em 1em 1em 0; justify-self: end; }
  show-example > .explanation { grid-area: explanation; width: var(--body-width); justify-self: center; }
  show-example > iframe { grid-area: demo; width: var(--body-width); justify-self: center; }
  show-example > .code pre { width: unset; font-size: clamp(0.5rem, 1.2vw, 0.9rem); border: none; margin: 0.25em; padding: 0.25em; }
  show-example > .code .state { grid-area: state; background: radial-gradient(circle at left 25% top 25%, oklch(95% 0.0 240), oklch(90% 0.01 240)); font-size: clamp(0.5rem, 1.5vw, 1.1rem); }
  show-example > .code .event { grid-area: event; background: radial-gradient(circle at left 25% top 25%, oklch(95% 0.0 30), oklch(90% 0.01 30)); }
  show-example > .code .body { grid-area: body; background: radial-gradient(circle at left 25% top 75%, oklch(95% 0.0 310), oklch(95% 0.01 310)); }
  show-example > .code .style { grid-area: style; background: radial-gradient(circle at left 25% top 25%, oklch(95% 0.0 150), oklch(95% 0.01 150)); }
  show-example > .editors { grid-area: editors; margin-left: 1em; align-self: center; }
  show-example > .editors form { display: inline-block; }

</style>

<style src="prism.css" />

<x:footer>
  <!-- https://prismjs.com/download.html#themes=prism&languages=clike+javascript -->
  <script src="build/prism.js"></script>
  <script type="module" src="examples.js"></script>

  Created Dec 2023
  with the help of
  <a href="https://prismjs.com/">Prism.js</a>; &#160;
  <!-- hhmts start -->Last modified: 03 Mar 2024<!-- hhmts end -->
</x:footer>
#+end_export
