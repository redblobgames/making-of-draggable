#+title: Draggable objects, 2022
#+date: <2022-12-23 Fri>
#+draft: t
#+options: toc:nil

Many of my interactive pages have a /draggable object/. I want the reader to move the object around, and I want the diagram to respond in some way. Here I'll document the code I use to make this work with both mouse and touch input, using browser features that are widely supported since 2020.  Here's what I want to support:

#+begin_export html
<figure id="diagram-pointer-events-fixed">
  <svg viewBox="-220 -75 440 150">
    <rect x="-220" y="-75" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag the circle with mouse or touch</figcaption>
</figure>
#+end_export

#+toc: headlines 1

#+begin_export html
<details>
<summary>History →</summary>
<p>
From 2011 to 2014 I used <a href="https://github.com/d3/d3-drag">d3-drag</a>, but for my non-d3 projects, I ended up developing my own mouse+touch code, which I wrote about <a href="/x/1845-draggable/">in 2018</a>.
</p>

<p>
By 2012 MS IE had added support for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events">pointer events</a> which unify and simplify mouse+touch handling. <a href="https://caniuse.com/pointer">Chrome added support in 2017; Firefox in 2018; Safari in 2020</a>.
</p>

<p>
Over the years browsers have changed the rules, including in 2017 when
<a href="https://developer.chrome.com/blog/scrolling-intervention/">Chrome changed some events to default to passive mode</a> which causes the page to scroll while you're trying to drag the object. This <a href="https://github.com/WICG/interventions/issues/18#issuecomment-276531695">broke some pages</a>. Safari <a href="https://github.com/WICG/interventions/issues/18#issuecomment-368703063">made this change in 2018</a>. Firefox maintained backwards compatibility.
</p>
</details>
#+end_export

I've run tests on Gecko/Firefox (Mac, Windows, Linux, Android), Blink/Chrome (Mac, Windows, Linux, Android), and WebKit/Safari (Mac, iPhone, iPad). I have /not/ tested on hoverable stylus, hybrid touch+mouse devices, or voice input.

This is the simple model in my head:

#+begin_src dot :file build/state.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> dragging [label = "pointerdown"];
    dragging -> dragging [label = "pointermove"];
    dragging -> initial [label = "pointerup"];
}
#+end_src

#+results:
[[file:build/state.svg]]

However it's not so simple! Mouses have multiple buttons. Touch events can include multiple fingers. Events can go to multiple destinations. Right click can trigger the context menu. Here's the code I ended up with:

#+begin_export html
<pre data-code="pointer" data-show="*"/>
#+end_export

On the rest of the page I'll show the code that didn't work, and explain how to fix it.

* Mouse events only
:PROPERTIES:
:CUSTOM_ID: mouse-events
:END:

The simplest thing to do is to capture =mousedown=, =mouseup=, and =mousemove= on the circle element. If the move occurs while dragging, then move the circle to the mouse position.

#+begin_src dot :file build/mouse-local.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> initial [label = "mousemove"];
    initial -> dragging [label = "mousedown"];
    dragging -> dragging [label = "mousemove"];
    dragging -> initial [label = "mouseup"];
}
#+end_src

#+begin_export html
<pre data-code="mouseLocal" />
#+end_export

Try the demo with a mouse:

#+begin_export html
<figure id="diagram-mouse-events-local" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using mouse events on circle</figcaption>
</figure>
#+end_export

This might seem like it works but it works badly.

- If you move the pointer quickly it is no longer over the circle, it stops receiving events.
- If you release the button while not on the circle, it will get stuck in the "dragging" state.

To fix these problems we can use =mousedown= on the circle to add =mousemove= and =mouseup= on the /document/. Then on =mouseup= we remove the =mousemove= and =mouseup= from the document.

#+begin_src dot :file build/mouse-document.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> dragging [label = "mousedown"];
    dragging -> dragging [label = "document\nmousemove"];
    dragging -> initial [label = "document\nmouseup"];
}
#+end_src

#+results:
[[file:build/mouse-document.svg]]

#+begin_export html
<pre data-code="mouseGlobal" />
#+end_export
Try it out. It works better.

#+begin_export html
<figure id="diagram-mouse-events-document" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using mouse events on document</figcaption>
</figure>
#+end_export

There are still a few issues, which we'll solve one by one.

- This code doesn't handle touch events.
- The text can get selected while trying to drag the circle.
- If you select all the text on the page, the drag can apply to the text instead of the circle.
- Right clicking the circle will bring up a context menu, which leaves the circle stuck in drag mode.

* Touch events
:PROPERTIES:
:CUSTOM_ID: touch-events
:END:

Touch events automatically /capture/ on =touchstart= and direct all =touchmove= events to the original element. This means we /don't/ have to temporarily put an event handler on =document=. We can go back to the logic in the first mouse example. If for any reason the browser needs to cancel the touch sequence, it sends =touchcancel=.

#+begin_src dot :file build/touch.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> initial [label = "touchmove"];
    initial -> dragging [label = "touchstart"];
    dragging -> dragging [label = "touchmove"];
    dragging -> initial [label = "touchend"];
    dragging -> initial [label = "touchcancel"];
}
#+end_src

#+begin_export html
<pre data-code="touch" />
#+end_export

Try the demo with a touch device:

#+begin_export html
<figure id="diagram-touch-events" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using touch events</figcaption>
</figure>
#+end_export

There are a few problems to deal with:

- When dragging the circle around, the page will scroll. That's because /both/ our drag handler /and/ the browser's scroll handler are active.
- Long pressing on the text will select it or bring up a context menu. This leaves us stuck in the dragging state.

* Pointer events
:PROPERTIES:
:CUSTOM_ID: pointer-events
:END:

To handle both mouse and touch events we end up having lots of different event handlers, and that's what I had to do [[href:/x/1845-draggable/][before 2021]]:

#+begin_src dot :file build/mouse-and-touch.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> dragging [label = "mousedown"];
    dragging -> dragging [label = "document\nmousemove"];
    dragging -> initial [label = "document\nmouseup"];
    initial -> initial [label = "touchmove"];
    initial -> dragging [label = "touchstart"];
    dragging -> dragging [label = "touchmove"];
    dragging -> initial [label = "touchend"];
    dragging -> initial [label = "touchcancel"];
}
#+end_src

#+results:
[[file:build/mouse-and-touch.svg]]

Pointer events attempt to unify mouse and touch events. The [[https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture][pointer capture]] feature lets us use the simpler logic that doesn't require us to add/remove global event handlers to the document like we had to with mouse events.

#+begin_src dot :file build/pointer.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> initial [label = "pointermove"];
    initial -> dragging [label = "pointerdown"];
    dragging -> dragging [label = "pointermove"];
    dragging -> initial [label = "pointerup"];
    dragging -> initial [label = "pointercancel"];
}
#+end_src

#+results:
[[file:build/pointer.svg]]

#+begin_export html
<pre data-code="pointer" data-show="capture" />
#+end_export

Much simpler! Try the demo with either a mouse or touch device:

#+begin_export html
<figure id="diagram-pointer-events" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using pointer events</figcaption>
</figure>
#+end_export

There are several things we still need to fix. It behaves particularly badly on touch devices because scrolling makes us lose pointer capture.

** Fix: capture
:PROPERTIES:
:CUSTOM_ID: fix-capture
:END:

The pointer capture feature lets us track the pointer even when it's not on the circle, the diagram, or even the browser window. With mouse events we had to put event handlers on =document=, but no longer.

| Try this                                   | Watch for  | Circle 1 | Circle 2 |
|--------------------------------------------+------------+----------+----------|
| drag quickly back and forth                | drag stops | yes ⛌   | no ✓    |
| drag outside diagram, come back in         | drag stops | yes ⛌   | no ✓    |
| drag outside diagram, let go               | drag stops | no ⛌    | yes ✓   |
| drag outside diagram, let go, come back in | drag stops | no ⛌    | yes ✓   |
| drag, alt+tab to another window            | drag stops | no ⛌    | yes ✓   |

#+begin_export html
<figure id="diagram-capture" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging without and with pointer capture</figcaption>
</figure>
#+end_export

*Try* this demo with the mouse. On touch devices it still loses pointer capture because of scrolling, which we'll fix later on this page. Pointer capture requires one additional line of code for common cases, or a second to handle some edge cases:

#+begin_export html
<pre data-code="pointer" data-highlight="capture" />
#+end_export

** Fix: text selection
:PROPERTIES:
:CUSTOM_ID: fix-user-select
:END:

When dragging the circle, the text inside gets selected sometimes. To fix this, use CSS ~user-select: none~ on the circle. There are two choices: either we can apply it /all/ the time, or apply it /only/ while dragging. If I apply it all the time, then the text won't ever be selectable.

| Try this        | Watch for        | Circle 1 | Circle 2 | Circle 3 |
|-----------------+------------------+----------+----------+----------|
| drag circle     | text is selected | yes ⛌   | no ✓    | no ✓    |
| select all text | text is selected | yes     | no       | yes     |

#+begin_export html
<figure id="diagram-text-select" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging affects text selection</figcaption>
</figure>
#+end_export

*Try* with a mouse: dragging Circle 1 a few times and you'll see sometimes the text gets selected. Both Circle 2 and Circle 3 do not have that problem. *Try* selecting all text on the page to see the difference between Circle 2 and Circle 3; either behavior is a reasonable choice. The code I show here applies only while dragging (Circle 3's behavior):

#+begin_export html
<pre data-code="pointer" data-show="capture" data-highlight="text" />
#+end_export

** Fix: scrolling with touch

On touch devices, single-finger drag will scroll the page. But single-finger drag also drags the circle. By default, it will do /both/. The fix is to add CSS ~touch-action: none~ on the diagram. But this prevents scrolling /anywhere/ in the diagram:

#+begin_export html
<figure id="diagram-touch-action-all" class="w-full">
  <svg viewBox="-330 -50 660 100" class="touch-none">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Stop touch from scrolling anywhere on the diagram</figcaption>
</figure>
#+end_export


*Try* dragging the circle on a touch device. It shouldn't scroll. But then try scrolling by dragging the diagram. It doesn't scroll either. I want it to. So I looked for a better fix.

I want to stop scrolling /only/ if dragging the circle, not when dragging the diagram. The natural thing to try is applying the CSS to the circle alone. Another possible fix is to =preventDefault()= on =touchstart=. In Canvas and WebGL, check that the pointer is on the circle and conditionally prevent default.

| Try this     | Watch for    | Demo above | Circle 2 | Circle 3 | Circle 4 |
|--------------+--------------+------------+----------+----------+----------|
| drag circle  | page scrolls | no ✓      | yes ⛌   | no ✓    | no ✓    |
| drag diagram | page scrolls | no ⛌      | yes ✓   | yes ✓   | yes ✓   |

#+begin_export html
<figure id="diagram-touch-action" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging affects scrolling</figcaption>
</figure>
#+end_export

*Try* these on a touch device. Dragging Circle 2 will scroll the page. Dragging Circle 3 behaves badly. It looks like =touch-action= has to be on the diagram to have an effect; applying it only to the circle is not enough. Dragging Circle 4 behaves the way I want, and this is the code for it:

#+begin_export html
<pre data-code="pointer" data-show="capture text" data-highlight="scroll" />
#+end_export

The simplest solution is to apply CSS ~touch-action: none~ to the entire diagram, but you're like me, and that isn't what you want, then use the code above to stop scrolling /only/ on the draggable objects.

** Fix: text drag

Try selecting all text on the page, then drag the circle. This will trigger /text dragging/ on many browser+OS combination, where you can drag some text as an alternative to copy/paste. I want to allow this, /except/ when dragging the circle.

Fix is: =preventDefault()= on =dragstart= on the circle. This works in SVG but not in Canvas or WebGL. For those, check that the pointer is on the circle and conditionally prevent default.

TODO: demo

| Try this    | Watch for       | Circle 1 | Circle 2 |
|-------------+-----------------+----------+----------|
| drag circle | page text drags | yes ⛌   | no ✓    |

** Fix: context menu

Context menus are different across platforms, and that makes handling it tricky.

- Windows :: right click (down+up), ~Shift~ + ~F10~ key
- Linux :: right click, right button down, ~Shift~ + ~F10~ key
- Mac :: right button down, ~Ctrl~ + left click
- iPhone, iPad :: long press on text only
- Android :: long press on anything

There are more ways to bring up context menus (examples: two finger tap on Mac or Windows; right side click on Windows; press-and-hold on Wacom pens) but I haven't tested all of them.

Windows, right click, no capture:

- Firefox, Chrome, Edge :: pointerdown, pointerup, auxclick, contextmenu

Windows, right click, capture:

- Firefox :: pointerdown, get capture, pointerup, lose capture, auxclick, contextmenu
- Chrome, Edge :: pointerdown, get capture, pointerup, auxclick, lose capture, contextmenu

Linux right click, no capture:

- Firefox :: pointerdown, contextmenu, pointermove² while menu is up
- Chrome :: pointerdown, contextmenu, no pointermove² while menu is up

Linux hold right down, no capture:

- Firefox :: pointerdown, contextmenu, pointermove² while menu is up
- Chrome :: pointerdown, contextmenu, no pointermove² while menu is up

Linux right click, capture:

- Firefox :: pointerdown, contextmenu, get capture, pointermove² while menu is up tells us button released
- Chrome :: pointerdown, contextmenu, get capture; not until another click do we get pointerup, lose capture

Linux hold right down, capture:

- Firefox :: pointerdown, contextmenu, got capture, pointermove² while menu is up tells us button released; when releasing button, menu stays up but we get pointerup, lose capture
- Chrome :: pointerdown, contextmenu, got capture, no pointermove² while menu is up; when releasing button, menu stays up but we don't get pointerup; not until another click do we get pointerup, click, lose capture

Mac, ctrl + left click:

- Firefox :: pointermove with buttons≠0, contextmenu (no pointerdown or pointerup)
- Chrome :: pointerdown with button=left, contextmenu (no pointerup)
- Safari :: pointerdown with button=left, contextmenu (no pointerup); but subsequent clicks only fire contextmenu

Mac, right button down:

- Firefox :: pointerdown with button=right, contextmenu (no pointerup)
- Chrome :: pointerdown with button=right, contextmenu (no pointerup)
- Safari :: pointerdown with button=right, contextmenu (no pointerup); but subsequent right clicks only fire contextmenu

If we capture events on =pointerdown=, Firefox and Safari will keep the capture even after the button is released. Chrome will keep capture until you move the mouse, and then it will release capture. [This seems like a Firefox/Safari bug to me, as pointer capture is supposed to be automatically released on mouse up]

It's frustrating that on Mac, there's no =pointerup= or =pointercapture= when releasing the mouse button. On Linux, the =pointerup= only shows up if you click to exit the context menu. It doesn't show up if you press ~Esc~ to exit. The workaround is to watch =pointermove= events to see when no buttons are set. Windows doesn't seem to have these issues, as both =pointerdown= and =pointerup= are delivered before the context menu.

Android, long press:

- Firefox :: pointerdown, get capture, contextmenu, pointerup, lose capture
- Chrome :: pointerdown, get capture, contextmenu, pointerup or pointercancel¹, lose capture

¹if the finger moves at all, this starts a scroll event which cancels the captured pointer
²Firefox lets the page see events outside the menu overlay, whereas Chrome doesn't let the page see any events while the menu is up

------- tests --------

The problem is that if I'm using =pointerdown= and then =pointerup= to track the state of the mouse, and I never get =pointerup=, my code thinks I'm still holding the button down (and the browser's pointer capture is still active).


Try right clicking the circle. It will bring up a context menu. That itself is fine. Unfortunately the events aren't consistent across platforms:

#+attr_html: :class standard
| Windows     | Mac         | Linux       |
|-------------+-------------+-------------|
| =pointerdown= | =pointerdown= | =pointerdown= |
| =pointerup=   |             |             |
| =auxclick=    |             |             |
| =contextmenu= | =contextmenu= | =contextmenu= |
|             | =pointerup= † |             |
|             | =auxclick= †  |             |

What should we do?

- https://www.w3.org/TR/pointerevents/#the-pointerdown-event says =preventDefault()= on =pointerdown= does /not/ stop click or =contextmenu= events. I can =preventDefault()= on =contextmenu= to prevent the menu. But I still want to get =pointerup= and/or =pointercancel=! I think I have to treat =contextmenu= as the up event which means I'll get multiple up events on Windows.

- https://w3c.github.io/pointerevents/#the-button-property says =button= = 0. indicates the primary button. This would let me exclude middle button and right button. But I still get a =pointerdown.left= on Mac/Chrome and Mac/Safari (not on Mac/Firefox) so this may not be enough.

- on pointermove, if we have pointer capture, we could check the state of the buttons?? TODO: test this!  it's mentioned as a workaround on https://github.com/w3c/pointerevents/issues/408

TODO: demo of both solutions?

| Try this              | Watch for    | Circle 1 | Circle 2 | Circle 3 |
|-----------------------+--------------+----------+----------+----------|
| right click on circle | circle moves | yes ⛌   | no ?     | yes ?    |
| right drag on circle  | circle moves |          |          |          |



** Feature: handle drag offset

This is not implementation specific, but a design issue. If you pick up the edge of the circle then you want to keep holding it at /that/ point, not from the center. The solution is to remember where the center is relative to where you started the drag. Then when you move the object, you add that offset back in.

TODO: demo both ways (although it duplicates little-details page) ; could draw something showing the pick up point

| Try this                 | Watch for    | Circle 1 | Circle 2 |
|--------------------------+--------------+----------+----------|
| drag from edge of circle | circle jumps | yes ⛌   | no ✓    |

** Feature: handle multitouch

isPrimary vs pointer id; need to test what happens if there are two independent drags going on

** Feature: handle simultaneous dragging

** TODO: what about multiple buttons?

So here's a tricky one. If you are using multiple buttons at the same time, what happens? The Pointer Events spec says that the /first/ button that was pressed leads to a =pointerdown= event, and the /last/ one that was released leads to a =pointerup= event. But that means we might get a up event on a different button than the down event.

#+begin_src dot :cmd circo :file build/multiple-buttons.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];

    neither;
    leftbutton [label = "left\nbutton"];
    rightbutton [label = "right\nbutton"];
    bothbuttons [label = "both\nbuttons"];

    neither -> leftbutton [label = "pointerdown\nleft"];
    neither -> rightbutton [label = "pointerdown\nright"];
    leftbutton -> neither [label = "pointerup\nleft"];
    leftbutton -> bothbuttons [label = "pointermove"];
    rightbutton -> neither [label = "pointerup\nright"];
    rightbutton -> bothbuttons [label = "pointermove"];
    bothbuttons -> leftbutton [label = "pointermove"];
    bothbuttons -> rightbutton [label = "pointermove"];
}
#+end_src

#+results:
[[file:build/multiple-buttons.svg]]

This doesn't seem to be what I want, but [[https://www.w3.org/TR/pointerevents/#chorded-button-interactions][it's what Pointer Events do]]. The workaround is to check the button state in =pointermove=. But /pointer capture/ continues until you release /all/ the buttons, unless you explicitly release capture.

Mouse Events behave the way I want but don't handle touch events.

** TODO: what about  multiple mice?

- mousedown (mouse 1)
- mousedown (mouse 2)
- mouseup (mouse 2)
- I stop dragging but the mouse that started the drag is still dragging

Does =PointerEvent.pointerId= help here?

What happens when ipad is used to control mouse, or mouse is used to control ipad?


TODO: test middle clicking to drag, like some mice support on Windows and maybe Linux

TODO: test left click drag, then right button down, then left/right up. Since I only have one dragging state it might get confused.

https://www.w3.org/TR/pointerevents/#the-primary-pointer says

#+begin_quote
Current operating systems and user agents don't usually have a concept of multiple mouse inputs. When more than one mouse device is present (for instance, on a laptop with both a trackpad and an external mouse), all mouse devices are generally treated as a single device - movements on any of the devices are translated to movement of a single mouse pointer, and there is no distinction between button presses on different mouse devices. For this reason, there will usually only be a single mouse pointer, and that pointer will be primary.
#+end_quote


** TODO: test nested dragging

- need =stopPropagation()= to prevent inner draggable from passing events up to outer draggable

* Vue version

I think it'll look something like this

#+begin_src xml
<template>
  <g
    :transform="`translate(${pos.x},${pos.y})`"
    @pointerdown.left="start" @pointerup="end" 
    @pointermove="dragging ? move($event) : null"
    @pointercancel="end" @lostpointercapture="end"
    @touchstart.prevent="" @dragstart.prevent="">
    :class="{dragging}"
    <slot />
  </g>
</template>

<style>
  g { cursor: grab; }
  g.dragging { user-select: none; cursor: grabbing; }
</style>

<script setup>
// pos is a prop {x: y:}

const dragging = ref(false);

function start(event) {
  if (event.ctrlKey) return;
  let {x, y} = convertPixelToSvgCoord(event);
  dragging.value = {dx: pos.x - x, dy: pos.y - y,
                    pointerId: event.pointerId};
  el.setPointerCapture(event.pointerId);
}

function end(event) {
  dragging.value = null;
}

function move(event) {
  if (!(event.buttons & 1)) return end(event);
  if (event.pointerId !== dragging.value.pointerId) return;
  let {x, y} = convertPixelToSvgCoord(event);
  $emit('move', {
    x: x + dragging.value.dx,
    y: y + dragging.value.dy,
  });
}
</script>
#+end_src
* Notes - event log

[[href:eventlog.html][eventlog.html]]

Testing a click:

- Desktop:
  - Firefox/Mac, Chrome/Mac, Safari/Mac, Firefox/Windows, Chrome/Windows, Edge/Windows, Firefox/Linux all produce pointerdown, mousedown, pointerup, mouseup, click
  - Firefox/Mac: if loading a page and the mouse is already over an element, will fire mouseover,mouseenter but not pointerover,pointerenter until the mouse is moved a tiny bit {need to test on Firefox/Windows, Firefox/Linux but probably does the same there}
  - Mac: if you mouse down over the circle and then alt+tab to another window and then release the mouse, the web page still gets pointerup, mouseup, pointerout, pointerleave, mouseout,  mouseleave (!). It also gets those if you put the computer to sleep. On Windows, it will go out as soon as you press alt+tab, and not come back when you switch to the same app, whereas on Mac it triggers pointerover etc when you come back to the app (further testing needed)
  - Firefox vs Chrome (both Mac and Windows): if your mouse goes under the element when you scroll the page with the keyboard, Firefox will fire mouseover, mouseenter whereas Chrome will fire pointerover, pointerenter, mouseover, mouseenter. I feel like Chrome is doing the right thing here. [TODO: [[https://bugzilla.mozilla.org/][file a bug]]]

- Mobile:
  - Safari/iOS, Firefox/Android, Chrome/Android all produce pointerdown, touchstart, pointerup, touchend, but if quick: also produce [mousedown, mouseup, click]
  - Android: contextmenu event if holding down; need to preventDefault to prevent the menu from showing up
  - Android: if there's text in the draggable event, need to use user-select:none to prevent text from being selected. If it's in the middle of text, might be best to apply apply it only during a drag event; otherwise it would prevent text selection when not dragging.

* Notes on dragging

[[href:tests.html][tests.html]]

- Need touchstart.prevent to prevent scrolling
- Need either pointerdown.prevent or user-select:none to prevent double click from selecting text

TODO: test tablet

* Variations

* Notes

=pointerdown= + =pointerup= will trigger =click= (left mouse button) or =auxclick= (middle mouse button) or =contextmenu= (right mouse button)

#+begin_comment
https://stackoverflow.com/questions/29952543/how-do-i-prevent-org-mode-from-executing-all-of-the-babel-source-blocks says that there's no really good way to tell org babel to regenerate the diagrams only explicitly and not automatically on export :-(
#+end_comment


#+begin_export html
<style>
  svg { 
    background: #eee; 
    box-shadow: 0 1px 3px 1px rgb(0 0 0 / 0.3); 
    width: calc(1.2 * var(--body-width)); 
  }

  details { padding: 0 1em; }
  details p { margin: 0.5em; padding: 0 1em; }
  details[open] { 
    background: linear-gradient(to right, hsl(200 10% 95%), white);
    border: 2px solid hsl(200 10% 70%); 
    border-right-width: 0; 
  }

  /* tailwind inspired */
  .select-none { user-select: none; }
  .touch-none { touch-action: none; }

  /* Prism.js theme, want to use mostly subdued colors */
  .token.operator { font-weight: bold; }
  .token.parameter { font-weight: bold; }
  .token.punctuation, .token.parameter .token.punctuation { color: #c9c9c4; }
  .token.keyword { color: hsl(220 20% 50%); font-weight: bold; }
  .token.keyword + .token.function { color: hsl(220 50% 50%); font-weight: bold; }
  .token.number { color: #000; }
  .token.string { color: #888; }
  /* I also want to highlight certain lines */
  .highlight { background: hsl(180 75% 90%); }
</style>

<x:footer>
  <svg width="0" height="0">
    <defs>
      <pattern id="pattern-dots" width="10" height="10" patternUnits="userSpaceOnUse">
        <circle cx="5" cy="5" fill="hsl(0 10% 80%)" r="1" />
      </pattern>
    </defs>
  </svg>
  <!-- https://prismjs.com/download.html#themes=prism&languages=clike+javascript -->
  <script src="build/prism.js"></script>
  <script type="module" src="draggable.js"></script>

  Created 23 Dec 2022
  with the help of
  <a href="https://prismjs.com/">Prism.js</a>; &#160;
  <!-- hhmts start -->Last modified: 13 Feb 2023<!-- hhmts end -->
</x:footer>
#+end_export
