#+title: Draggable objects, 2022
#+date: <2022-12-23 Fri>
#+draft: t
#+options: toc:nil

Many of my interactive pages have a /draggable object/. I want the reader to move the object around, and I want the diagram to respond in some way. Here I'll document the code I use to make this work with both mouse and touch input, using browser features that are widely supported since 2020.  Here's what I want to support:

#+begin_export html
<figure id="diagram-introduction">
  <svg viewBox="-220 -75 440 150">
    <rect x="-220" y="-75" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag the circle with mouse or touch</figcaption>
</figure>
#+end_export

#+toc: headlines 1

#+begin_export html
<details>
<summary>History →</summary>
<p>
From 2011 to 2014 I used <a href="https://github.com/d3/d3-drag">d3-drag</a>, but for my non-d3 projects, I ended up developing my own mouse+touch code, which I wrote about <a href="/x/1845-draggable/">in 2018</a>.
</p>

<p>
By 2012 MS IE had added support for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events">pointer events</a> which unify and simplify mouse+touch handling. <a href="https://caniuse.com/pointer">Chrome added support in 2017; Firefox in 2018; Safari in 2020</a>.
</p>

<p>
Over the years browsers have changed the rules, including in 2017 when
<a href="https://developer.chrome.com/blog/scrolling-intervention/">Chrome changed some events to default to passive mode</a> which causes the page to scroll while you're trying to drag the object. This <a href="https://github.com/WICG/interventions/issues/18#issuecomment-276531695">broke some pages</a>. Safari <a href="https://github.com/WICG/interventions/issues/18#issuecomment-368703063">made this change in 2018</a>. Firefox maintained backwards compatibility.
</p>
</details>
#+end_export

I've run tests on Gecko/Firefox (Mac, Windows, Linux, Android), Blink/Chrome (Mac, Windows, Linux, Android), and WebKit/Safari (Mac, iPhone, iPad). I have /not/ tested on hoverable stylus, hybrid touch+mouse devices, or voice input.

This is the simple model in my head:

#+begin_src dot :file build/state.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> dragging [label = "pointerdown"];
    dragging -> dragging [label = "pointermove"];
    dragging -> initial [label = "pointerup"];
}
#+end_src

#+results:
[[file:build/state.svg]]

However it's not so simple! Mouses have multiple buttons. Touch events can include multiple fingers. Events can go to multiple destinations. Right click can trigger the context menu. Here's the code I ended up with:

#+begin_export html
<pre data-code="pointer" data-show="*"/>
#+end_export

On the rest of the page I'll show the code that didn't work, and explain how to fix it.

* Mouse events only
:PROPERTIES:
:CUSTOM_ID: mouse-events
:END:

The simplest thing to do is to capture =mousedown=, =mouseup=, and =mousemove= on the circle element. If the move occurs while dragging, then move the circle to the mouse position.

#+begin_src dot :file build/mouse-local.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> initial [label = "mousemove"];
    initial -> dragging [label = "mousedown"];
    dragging -> dragging [label = "mousemove"];
    dragging -> initial [label = "mouseup"];
}
#+end_src

#+begin_export html
<pre data-code="mouseLocal" />
#+end_export

*Try* the demo with a mouse:

#+begin_export html
<figure id="diagram-mouse-events-local" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using mouse events on circle</figcaption>
</figure>
#+end_export

This might seem like it works but it works badly.

- If you move the pointer quickly it is no longer over the circle, it stops receiving events.
- If you release the button while not on the circle, it will get stuck in the "dragging" state.

To fix these problems we can use =mousedown= on the circle to add =mousemove= and =mouseup= on the /document/. Then on =mouseup= we remove the =mousemove= and =mouseup= from the document.

#+begin_src dot :file build/mouse-document.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> dragging [label = "mousedown"];
    dragging -> dragging [label = "document\nmousemove"];
    dragging -> initial [label = "document\nmouseup"];
}
#+end_src

#+results:
[[file:build/mouse-document.svg]]

#+begin_export html
<pre data-code="mouseGlobal" />
#+end_export
Try it out. It works better.

#+begin_export html
<figure id="diagram-mouse-events-document" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using mouse events on document</figcaption>
</figure>
#+end_export

There are still a few issues, which we'll solve one by one.

- This code doesn't handle touch events.
- The text can get selected while trying to drag the circle.
- If you the text around the diagram, the drag can apply to the text instead of the circle.
- Right clicking the circle will bring up a context menu, which leaves the circle stuck in drag mode.

* Touch events
:PROPERTIES:
:CUSTOM_ID: touch-events
:END:

Touch events automatically /capture/ on =touchstart= and direct all =touchmove= events to the original element. This means we /don't/ have to temporarily put an event handler on =document=. We can go back to the logic in the first mouse example. If for any reason the browser needs to cancel the touch sequence, it sends =touchcancel=.

#+begin_src dot :file build/touch.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> initial [label = "touchmove"];
    initial -> dragging [label = "touchstart"];
    dragging -> dragging [label = "touchmove"];
    dragging -> initial [label = "touchend"];
    dragging -> initial [label = "touchcancel"];
}
#+end_src

#+begin_export html
<pre data-code="touch" />
#+end_export

*Try* the demo with a touch device:

#+begin_export html
<figure id="diagram-touch-events" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using touch events</figcaption>
</figure>
#+end_export

There are a few problems to deal with:

- When dragging the circle around, the page will scroll. That's because /both/ our drag handler /and/ the browser's scroll handler are active.
- Long pressing on the text will select it or bring up a context menu. This leaves us stuck in the dragging state.

* Pointer events
:PROPERTIES:
:CUSTOM_ID: pointer-events
:END:

To handle both mouse and touch events we end up having lots of different event handlers, and that's what I had to do [[href:/x/1845-draggable/][before 2021]]:

#+begin_src dot :file build/mouse-and-touch.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> dragging [label = "mousedown"];
    dragging -> dragging [label = "document\nmousemove"];
    dragging -> initial [label = "document\nmouseup"];
    initial -> initial [label = "touchmove"];
    initial -> dragging [label = "touchstart"];
    dragging -> dragging [label = "touchmove"];
    dragging -> initial [label = "touchend"];
    dragging -> initial [label = "touchcancel"];
}
#+end_src

#+results:
[[file:build/mouse-and-touch.svg]]

Pointer events attempt to unify mouse and touch events. The [[https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture][pointer capture]] feature lets us use the simpler logic that doesn't require us to add/remove global event handlers to the document like we had to with mouse events.

#+begin_src dot :file build/pointer.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];
    
    rankdir=LR;
    initial -> initial [label = "pointermove"];
    initial -> dragging [label = "pointerdown"];
    dragging -> dragging [label = "pointermove"];
    dragging -> initial [label = "pointerup"];
    dragging -> initial [label = "pointercancel"];
}
#+end_src

#+results:
[[file:build/pointer.svg]]

#+begin_export html
<pre data-code="pointer" data-show="capture" />
#+end_export

Much simpler! *Try* the demo with either a mouse or touch device:

#+begin_export html
<figure id="diagram-pointer-events" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Drag using pointer events</figcaption>
</figure>
#+end_export

Circle 1 uses the code above, but needs improvement. Circle 2 uses the code from the top of the page, and behaves much better. Let's go through each of the fixes—

** Fix: scrolling with touch
:PROPERTIES:
:CUSTOM_ID: touch-action
:END:

On touch devices, single-finger drag will scroll the page. But single-finger drag /also/ drags the circle. By default, it will do /both/! The simplest fix is to add CSS ~touch-action: none~ on the diagram. But this prevents scrolling /anywhere/ in the diagram:

#+begin_export html
<figure id="diagram-touch-action-all" class="w-full">
  <svg viewBox="-330 -50 660 100" class="touch-none">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-slashes)" />
  </svg>
  <figcaption>Stop touch from scrolling anywhere on the diagram</figcaption>
</figure>
#+end_export

*Try* dragging the circle on a touch device. It shouldn't scroll. But then try scrolling by dragging the diagram. It doesn't scroll either, but I want it to. I want to stop scrolling /only/ if dragging the circle, not when dragging the diagram.

| Try this     | Watch for    | Circle 1 | Circle 2 | Circle 3 | Circle 4 |
|--------------+--------------+------------+----------+----------+----------|
| drag circle  | page scrolls | no ✓      | yes ⛌   | yes ⛌   | no ✓    |
| drag diagram | page scrolls | no ⛌      | yes ✓   | yes ✓   | yes ✓   |

#+begin_export html
<figure id="diagram-touch-action" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging affects scrolling</figcaption>
</figure>
#+end_export

*Try* these on a touch device. 

- The earlier demo with Circle 1 (~touch-action: none~ on the diagram) stops scrolling on the circle and also on the diagram. 
- Circle 2 (default) doesn't stop scrolling on either. 
- Circle 3 (~touch-action: none~ on the circle only) behaves badly. It looks like the CSS has to be on the diagram to have an effect; applying it only to the circle is not enough. 
- Circle 4 (~.preventDefault()~ on =touchstart=) behaves the way I want, and this is the code for it:

#+begin_export html
<pre data-code="pointer" data-show="capture" data-highlight="scroll" />
#+end_export

Note that the ~.preventDefault()~ needs to be on =touchstart=, not on =pointerstart=. In Canvas and WebGL, check that the pointer is on the circle and conditionally prevent default.

** Fix: capture the mouse
:PROPERTIES:
:CUSTOM_ID: fix-capture
:END:

The pointer capture feature lets us track the pointer even when it's not on the circle, the diagram, or even the browser window. With mouse events we had to put event handlers on =document=, but no longer.

| Try this                                   | Watch for  | Circle 1 | Circle 2 |
|--------------------------------------------+------------+----------+----------|
| drag quickly back and forth                | drag stops | yes ⛌   | no ✓    |
| drag outside diagram, come back in         | drag stops | yes ⛌   | no ✓    |
| drag outside diagram, let go               | drag stops | no ⛌    | yes ✓   |
| drag outside diagram, let go, come back in | drag stops | no ⛌    | yes ✓   |
| drag, alt+tab to another window            | drag stops | no ⛌    | yes ✓   |

#+begin_export html
<figure id="diagram-capture" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging without and with pointer capture</figcaption>
</figure>
#+end_export

*Try* this demo with a mouse. Touch devices automatically capture so they won't show a difference here. Pointer capture requires one additional line of code for common cases, or a second to handle some edge cases:

#+begin_export html
<pre data-code="pointer" data-show="scroll" data-highlight="capture" />
#+end_export

** Fix: text selection
:PROPERTIES:
:CUSTOM_ID: fix-user-select
:END:

When dragging the circle, the text inside gets selected sometimes. To fix this, use CSS ~user-select: none~ on the circle. There are two choices: either we can apply it /all/ the time, or apply it /only/ while dragging. If I apply it all the time, then the text won't ever be selectable.

| Try this        | Watch for        | Circle 1 | Circle 2 | Circle 3 |
|-----------------+------------------+----------+----------+----------|
| drag circle     | text is selected | yes ⛌   | no ✓    | no ✓    |
| select all text | text is selected | yes     | no       | yes     |

#+begin_export html
<figure id="diagram-text-select" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging affects text selection</figcaption>
</figure>
#+end_export

*Try* dragging Circle 1 with the mouse a few times and you'll see sometimes the text gets selected. With touch devices, long press can select the text. Both Circle 2 and Circle 3 do not have that problem. *Try* selecting all text on the page to see the difference between Circle 2 and Circle 3; either behavior is a reasonable choice. The code I show here applies only while dragging (Circle 3's behavior):

#+begin_export html
<pre data-code="pointer" data-show="capture scroll" data-highlight="text" />
#+end_export

** Fix: text and image drag
:PROPERTIES:
:CUSTOM_ID: fix-systemdrag
:END:

Windows, Linux, and Mac support inter-application /drag and drop/ of text and images, and an alternative to copy/paste. This interferes with the object dragging on my pages. The fix is to ~preventDefault()~ on =dragstart=.

| Try this                 | Watch for       | Circle 1 | Circle 2 |
|--------------------------+-----------------+----------+----------|
| select text, drag circle | page text drags | yes ⛌    | no ✓    |

#+begin_export html
<figure id="diagram-systemdrag" class="w-full">
  <div><b>Select text</b> → <tt>[from here</tt></div>
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <div><tt>to here]</tt> ←</div>
  <figcaption>Selected text interferes with dragging</figcaption>
</figure>
#+end_export

*Try* this demo with a mouse.
@@html:<button onclick="diagramSystemDragSetSelection()">Select the text</button>@@
around the diagram, then drag Circle 1. On most desktop systems I've tested, text or image dragging takes priority over the circle dragging by default. Circle 2 prioritizes the circle dragging. Behavior varies a little bit across browsers and operating systems. The fix is one extra line:

#+begin_export html
<pre data-code="pointer" data-show="capture scroll text" data-highlight="systemdrag" />
#+end_export

** Fix: context menu
:PROPERTIES:
:CUSTOM_ID: fix-contextmenu
:END:

Context menus are different across platforms, and that makes handling it tricky. I want to allow context menus without them interfering with dragging the circle.

| System  | Activation                             |
|---------+----------------------------------------|
| Windows | right click (down+up), ~Shift~ + ~F10~ key |
| Linux   | right button down, ~Shift~ + ~F10~ key     |
| Mac     | right button down, ~Ctrl~ + left click   |
| iOS     | long press on text only                |
| Android | long press on anything                 |

One problem is that I will see a =pointerdown= event and only /sometimes/ a =pointerup= event. That means I might think the button is still down when it's not. It's frustrating! I realized that I should only set the dragging state on /left/ mouse button, and ignore the right mouse button. Then I don't have to worry about most of the differences.

#+begin_export html
<details>
<summary>I made some notes during testing, but most of them don't matter for my use case.</summary>
#+end_export

Across platforms, it looks like Firefox lets the page see events outside the menu overlay, whereas Chrome doesn't let the page see any events while the menu is up.

Windows, right click, no capture:

- Firefox, Chrome, Edge :: =pointerdown=, =pointerup=, =auxclick=, =contextmenu=

Windows, right click, capture:

- Firefox :: =pointerdown=, =gotpointercapture=, =pointerup=, =lostpointercapture=, =auxclick=, =contextmenu=
- Chrome, Edge :: =pointerdown=, =gotpointercapture=, =pointerup=, =auxclick=, =lostpointercapture=, =contextmenu=

Linux right click, no capture:

- Firefox :: =pointerdown=, =contextmenu=, =pointermove= while menu is up
- Chrome :: =pointerdown=, =contextmenu=, no =pointermove= while menu is up

Linux hold right down, no capture:

- Firefox :: =pointerdown=, =contextmenu=, =pointermove= while menu is up
- Chrome :: =pointerdown=, =contextmenu=, no =pointermove= while menu is up

Linux right click, capture:

- Firefox :: =pointerdown=, =contextmenu=, =gotpointercapture=, =pointermove= while menu is up tells us button released
- Chrome :: =pointerdown=, =contextmenu=, =gotpointercapture=; not until another click do we get =pointerup=, =lostpointercapture=

Linux hold right down, capture:

- Firefox :: =pointerdown=, =contextmenu=, =gotpointercapture=, =pointermove= while menu is up tells us button released; when releasing button, menu stays up but we get =pointerup=, =lostpointercapture=
- Chrome :: =pointerdown=, =contextmenu=, =gotpointercapture=, no =pointermove= while menu is up; when releasing button, menu stays up but we don't get =pointerup=; not until another click do we get =pointerup=, click, =lostpointercapture=

Mac, ctrl + left click:

- Firefox :: =pointermove= with buttons≠0, =contextmenu= (no =pointerdown= or =pointerup=)
- Chrome :: =pointerdown= with button=left, =contextmenu= (no =pointerup=)
- Safari :: =pointerdown= with button=left, =contextmenu= (no =pointerup=); but subsequent clicks only fire =contextmenu=

Mac, right button down:

- Firefox :: =pointerdown= with button=right, =contextmenu= (no =pointerup=)
- Chrome :: =pointerdown= with button=right, =contextmenu= (no =pointerup=)
- Safari :: =pointerdown= with button=right, =contextmenu= (no =pointerup=); but subsequent right clicks only fire =contextmenu=

If we capture events on =pointerdown=, Firefox and Safari will keep the capture even after the button is released. Chrome will keep capture until you move the mouse, and then it will release capture. [This seems like a Firefox/Safari bug to me, as pointer capture is supposed to be automatically released on mouse up]

It's frustrating that on Mac, there's no =pointerup= or =pointercapture= when releasing the mouse button. On Linux, the =pointerup= only shows up if you click to exit the context menu. It doesn't show up if you press ~Esc~ to exit. The workaround is to watch =pointermove= events to see when no buttons are set. Windows doesn't seem to have these issues, as both =pointerdown= and =pointerup= are delivered before the context menu.

Android, long press:

- Firefox :: =pointerdown=, get capture, =contextmenu=, =pointerup=, lose capture
- Chrome :: =pointerdown=, get capture, =contextmenu=, =pointerup= or =pointercancel= (if the finger moves at all, this starts a scroll event which cancels the captured pointer), lose capture

What are my options?

- [[https://www.w3.org/TR/pointerevents/#the-pointerdown-event][The spec says about pointerdown]] that =preventDefault()=  /not/ stop click or =contextmenu= events. I can =preventDefault()= on =contextmenu= to prevent the menu. But I still want to get =pointerup= and/or =pointercancel=! I think I have to treat =contextmenu= as the up event which means I'll get multiple up events on Windows.

- [[https://w3c.github.io/pointerevents/#the-button-property][The spec says about the button property]] that =button= = 0 indicates the primary button. This is how I will exclude the middle and right buttons. But I still get a =pointerdown.left= on Mac/Chrome and Mac/Safari (but not on Mac/Firefox) so I also have to check for the ~Ctrl~ key.

- Button changes not communicated through =pointerdown= or =pointerup= can still be sent on =pointermove=. It's mentioned as a workaround on [[https://github.com/w3c/pointerevents/issues/408][W3C's pointerevents issues page]].

#+begin_export html
</details>
#+end_export


| Try this                   | Watch for      | Circle 1 | Circle 2 | Circle 3 |
|----------------------------+----------------+----------+----------+----------|
| right click on circle      | circle is blue | yes ⛌    | no ✓    | no ✓    |
| ctrl+click on circle (mac) | circle is blue | yes ⛌    | yes ⛌    | no ✓    |
| right drag on circle       | circle is blue | yes ⛌    | no ✓    | no ✓    |

#+begin_export html
<figure id="diagram-contextmenu" class="w-full">
  <svg viewBox="-330 -50 660 100">
    <rect x="-330" y="-50" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Right mouse button down interferes with drag</figcaption>
</figure>
#+end_export

*Try* with the mouse: right click or drag on the circles. Try dismissing the menu with a click elsewhere, or by pressing ~Esc~. Sometimes Circle 1 will get stuck in a dragging state. Behavior varies across browsers and operating systems. The fix is to only drag on left button without ~Ctrl~ pressed:

#+begin_export html
<pre data-code="pointer" data-show="capture scroll text systemdrag" data-highlight="left ctrl" />
#+end_export

This solution also handles middle button down/click, which is used for scrolling on some systems.
Another option is to ~.preventDefault()~ on =contextmenu=, and allow dragging with the right button, but that doesn't handle the middle button.

** Feature: handle drag offset
:PROPERTIES:
:CUSTOM_ID: feature-offset
:END:

This is not implementation specific, but a design issue. If you pick up the edge of the circle then you want to keep holding it at /that/ point, not from the center. The solution is to remember where the center is relative to where you started the drag. Then when you move the object, you add that offset back in.

| Try this                 | Watch for    | Circle 1 | Circle 2 |
|--------------------------+--------------+----------+----------|
| drag from edge of circle | circle jumps | yes ⛌   | no ✓    |

#+begin_export html
<figure id="diagram-offset" class="w-full">
  <svg viewBox="-250 -60 500 120">
    <rect x="-250" y="-60" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Dragging feels better if relative to the initial pickup point</figcaption>
</figure>
#+end_export

*Try* with the mouse: drag the circle from the edge. Watch Circle 1 jump whereas Circle 2 does not. The same effect happens on touch devices but your finger might hide the jump. The fix is to change the =dragging= state from =true= / =false= to the relative position where the object was picked up, and then use that offset when later setting the position:

#+begin_export html
<pre data-code="pointer" data-show="capture scroll text systemdrag left ctrl" data-highlight="offset" />
#+end_export

Go back to the earlier diagrams on the page. Did you notice the jump? You may not have noticed, but implementing the offset does make dragging feel better. I've also written about this [[href:/making-of/little-things/#drag-point][on my page about little details]].

** Feature: simultaneous dragging
:PROPERTIES:
:CUSTOM_ID: feature-simultaneous-dragging
:END:

I think this is an edge case, but I was curious what it would take to support. Can we drag multiple objects at once, using different fingers or different mice?

For touch, the code I presented should already work! Go back to one of the previous demos and try it. However the code doesn't handle using two fingers to drag the /same/ object. The fix is when handling =pointerdown=, save ~event.pointerId~ to =state.dragging=. Then when handling =pointermove=, ignore the even if it's not the same =pointerId=. I don't have that implemented here, but try it out [[href:tests.html#test-2d-canvas-drag-a-handle][on my canvas dragging test]].

What about mice? The [[https://www.w3.org/TR/pointerevents/#the-primary-pointer][Pointer Events spec]] says

#+begin_quote
Current operating systems and user agents don't usually have a concept of multiple mouse inputs. When more than one mouse device is present (for instance, on a laptop with both a trackpad and an external mouse), all mouse devices are generally treated as a single device - movements on any of the devices are translated to movement of a single mouse pointer, and there is no distinction between button presses on different mouse devices. For this reason, there will usually only be a single mouse pointer, and that pointer will be primary.
#+end_quote

I think there isn't any way to drag different objects with different mice.

** Fix: chorded button presses
:PROPERTIES:
:CUSTOM_ID: fix-chords
:END:

So here's a tricky one. If you are using multiple buttons at the same time, what happens? Mouse Events send =mousedown= for each button press and =mouseup= for each button release. But Pointer Events work differently. The [[https://www.w3.org/TR/pointerevents/#chorded-button-interactions][Pointer Events spec]] says that the /first/ button that was pressed leads to a =pointerdown= event, and the /last/ one that was released leads to a =pointerup= event. But that means we might get a up event on a different button than the down event!

#+begin_src dot :cmd circo :file build/multiple-buttons.svg :exports results
digraph {
    node [fontname=Helvetica, fontsize=12, shape=circle, style=filled, color="#aaaaaa", fillcolor="#eeeeee"];
    edge [fontname=Courier, fontsize=10, fontcolor="#444422", color="#999999", fillcolor="#ffffff"];

    neither;
    leftbutton [label = "left\nbutton"];
    rightbutton [label = "right\nbutton"];
    bothbuttons [label = "both\nbuttons"];

    neither -> leftbutton [label = "pointerdown\nleft"];
    neither -> rightbutton [label = "pointerdown\nright"];
    leftbutton -> neither [label = "pointerup\nleft"];
    leftbutton -> bothbuttons [label = "pointermove"];
    rightbutton -> neither [label = "pointerup\nright"];
    rightbutton -> bothbuttons [label = "pointermove"];
    bothbuttons -> leftbutton [label = "pointermove"];
    bothbuttons -> rightbutton [label = "pointermove"];
}
#+end_src

#+results:
[[file:build/multiple-buttons.svg]]

| Try this                                 | Watch for | Circle 1 | Circle 2 |
|------------------------------------------+-----------+----------+----------|
| left down, right down, left up           | dragging  | yes ⛌    | no ✓    |

#+begin_export html
<figure id="diagram-chords" class="w-full">
  <svg viewBox="-250 -60 500 120">
    <rect x="-250" y="-60" width="100%" height="100%" fill="url(#pattern-dots)" />
  </svg>
  <figcaption>Multiple button presses is tricky</figcaption>
</figure>
#+end_export

*Try* with the mouse: press the left button, press the right button (this may bring up a context menu but ignore it), then release the left button. Is the circle still dragging?

This is where I draw the line. I don't care to handle this or many other edge cases. The fix is to check the button state in =pointermove=.

#+begin_export html
<pre data-code="pointer" data-show="capture scroll text systemdrag left ctrl offset" data-highlight="chords" />
#+end_export

Separately, the /pointer capture/ continues until you release /all/ the buttons, unless you explicitly release capture. I'm not handling this or many other edge cases.

** Feature: nested dragging

- need =stopPropagation()= to prevent inner draggable from passing events up to outer draggable

Point to demo on tests page

* Vue version

I think it'll look something like this

#+begin_src xml
<template>
  <g
    :transform="`translate(${pos.x},${pos.y})`"
    @pointerdown.left="start" @pointerup="end" 
    @pointermove="dragging ? move($event) : null"
    @pointercancel="end" @lostpointercapture="end"
    @touchstart.prevent="" @dragstart.prevent="">
    :class="{dragging}"
    <slot />
  </g>
</template>

<style>
  g { cursor: grab; }
  g.dragging { user-select: none; cursor: grabbing; }
</style>

<script setup>
// pos is a prop {x: y:}

const dragging = ref(false);

function start(event) {
  if (event.ctrlKey) return;
  let {x, y} = convertPixelToSvgCoord(event);
  dragging.value = {dx: pos.x - x, dy: pos.y - y,
                    pointerId: event.pointerId};
  el.setPointerCapture(event.pointerId);
}

function end(event) {
  dragging.value = null;
}

function move(event) {
  if (!(event.buttons & 1)) return end(event);
  if (event.pointerId !== dragging.value.pointerId) return;
  let {x, y} = convertPixelToSvgCoord(event);
  $emit('move', {
    x: x + dragging.value.dx,
    y: y + dragging.value.dy,
  });
}
</script>
#+end_src

* Notes - event log

[[href:eventlog.html][eventlog.html]]

TODO: most of this should move to the other page

Testing a click:

- Desktop:
  - Firefox/Mac, Chrome/Mac, Safari/Mac, Firefox/Windows, Chrome/Windows, Edge/Windows, Firefox/Linux all produce pointerdown, mousedown, pointerup, mouseup, click
  - Firefox/Mac: if loading a page and the mouse is already over an element, will fire mouseover,mouseenter but not pointerover,pointerenter until the mouse is moved a tiny bit {need to test on Firefox/Windows, Firefox/Linux but probably does the same there}
  - Mac: if you mouse down over the circle and then alt+tab to another window and then release the mouse, the web page still gets pointerup, mouseup, pointerout, pointerleave, mouseout,  mouseleave (!). It also gets those if you put the computer to sleep. On Windows, it will go out as soon as you press alt+tab, and not come back when you switch to the same app, whereas on Mac it triggers pointerover etc when you come back to the app (further testing needed)
  - Firefox vs Chrome (both Mac and Windows): if your mouse goes under the element when you scroll the page with the keyboard, Firefox will fire mouseover, mouseenter whereas Chrome will fire pointerover, pointerenter, mouseover, mouseenter. I feel like Chrome is doing the right thing here. [TODO: [[https://bugzilla.mozilla.org/][file a bug]]]

- Mobile:
  - Safari/iOS, Firefox/Android, Chrome/Android all produce pointerdown, touchstart, pointerup, touchend, but if quick: also produce [mousedown, mouseup, click]
  - Android: contextmenu event if holding down; need to preventDefault to prevent the menu from showing up
  - Android: if there's text in the draggable event, need to use user-select:none to prevent text from being selected. If it's in the middle of text, might be best to apply apply it only during a drag event; otherwise it would prevent text selection when not dragging.

* Notes on dragging

[[href:tests.html][tests.html]]

- Need touchstart.prevent to prevent scrolling
- Need either pointerdown.prevent or user-select:none to prevent double click from selecting text

* Variations


#+begin_comment
https://stackoverflow.com/questions/29952543/how-do-i-prevent-org-mode-from-executing-all-of-the-babel-source-blocks says that there's no really good way to tell org babel to regenerate the diagrams only explicitly and not automatically on export :-(
#+end_comment


#+begin_export html
<style>
  main svg { 
    max-width: 90%;
    background: #eee; 
    box-shadow: 0 1px 3px 1px rgb(0 0 0 / 0.3);
    width: calc(1.2 * var(--body-width)); 
  }

  main pre {
    /* some of my code is slightly too wide for my default width */
    width: calc(1.1 * var(--body-width));
  }

  details { padding: 0 1em; }
  details p, details dl { margin: 0.5em; padding: 0 1em; }
  details[open] { 
    background: linear-gradient(to right, hsl(200 10% 95%), white);
    border: 2px solid hsl(200 10% 70%); 
    border-right-width: 0; 
  }

  /* tailwind inspired */
  .select-none { user-select: none; }
  .touch-none { touch-action: none; }

  /* Prism.js theme, want to use mostly subdued colors */
  .token.operator { font-weight: bold; }
  .token.parameter { font-weight: bold; }
  .token.punctuation, .token.parameter .token.punctuation { color: #c9c9c4; }
  .token.keyword { color: hsl(220 20% 50%); font-weight: bold; }
  .token.keyword + .token.function { color: hsl(220 50% 50%); font-weight: bold; }
  .token.number { color: #000; }
  .token.string { color: #888; }
  /* I also want to highlight certain lines */
  .highlight { background: hsl(180 75% 90%); }
</style>

<x:footer>
  <svg width="0" height="0">
    <defs>
      <pattern id="pattern-dots" width="10" height="10" patternUnits="userSpaceOnUse">
        <circle cx="5" cy="5" fill="hsl(0 10% 80%)" r="1" />
      </pattern>
      <pattern id="pattern-slashes" width="7" height="7" patternUnits="userSpaceOnUse" patternTransform="rotate(30 0 0)">
        <line y2="7" fill="none" stroke="hsl(0 10% 80%)" stroke-width="1" />
      </pattern>
    </defs>
  </svg>
  <!-- https://prismjs.com/download.html#themes=prism&languages=clike+javascript -->
  <script src="build/prism.js"></script>
  <script type="module" src="draggable.js"></script>

  Created 23 Dec 2022
  with the help of
  <a href="https://prismjs.com/">Prism.js</a>; &#160;
  <!-- hhmts start -->Last modified: 14 Feb 2023<!-- hhmts end -->
</x:footer>
#+end_export
